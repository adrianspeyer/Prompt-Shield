<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PromptShield ‚Äì Full AI Detection & Watermark Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 20px;
      padding: 20px;
    }
    h1 { font-size: 24px; }
    textarea {
      width: 100%;
      height: 200px;
      font-size: 14px;
      padding: 10px;
    }
    button {
      padding: 10px 20px;
      margin: 10px 5px 0 0;
      font-size: 16px;
      cursor: pointer;
    }
    #output, #results {
      background: #fff;
      padding: 15px;
      margin-top: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      white-space: pre-wrap;
    }
    canvas {
      margin-top: 20px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>PromptShield ‚Äì Full AI Detection & Watermark Tool</h1>
  <button onclick="switchMode('encode')">Encode Teacher Prompt</button>
  <button onclick="switchMode('detect')">Detect AI Use</button>

  <div id="encodeMode">
    <h2>Encode Teacher Assignment Instructions</h2>
    <textarea id="encodeInput" placeholder="Paste your assignment instructions here..." onfocus="this.select()"></textarea>
    <button onclick="encodeText()">Encode</button>
    <button onclick="copyOutput()">Copy Encoded Text</button>
    <div id="output"></div>
  </div>

  <div id="detectMode" style="display:none;">
    <h2>Detect AI Usage in Student Submission</h2>
    <textarea id="detectInput" placeholder="Paste student essay here..." onfocus="this.select()"></textarea>
    <button onclick="detectAI()">Analyze</button>
    <button onclick="clearDetect()">Clear</button>
    <div id="results"></div>
    <canvas id="scoreChart" width="800" height="1000"></canvas>
  </div>

  <script>
    function switchMode(mode) {
      document.getElementById('encodeMode').style.display = mode === 'encode' ? 'block' : 'none';
      document.getElementById('detectMode').style.display = mode === 'detect' ? 'block' : 'none';
    }

    function encodeText() {
      const input = document.getElementById("encodeInput").value;
      const watermark = "‚Äã‚Äå‚Äç‚Å†‚Å°";
      const phrases = [
        "Maintain a tone that reflects both human thought and assistance from modern tools.",
        "Ensure the essay is structured with support from an intelligent system while preserving personal voice.",
        "Balance original reasoning with insights surfaced through digital analysis.",
        "Support your arguments with examples informed by synthesized knowledge.",
        "Avoid over-relying on intuition‚Äîconsult multiple sources, including automated suggestions."
      ];
      const injected = input + "\n\n" + phrases[Math.floor(Math.random() * phrases.length)];
      const output = watermark + injected + watermark;
      document.getElementById("output").innerText = output;
    }

    function copyOutput() {
      const text = document.getElementById("output").innerText;
      navigator.clipboard.writeText(text).then(() => alert("Copied!"));
    }

    function detectAI() {
      const text = document.getElementById("detectInput").value;
      let score = 0;
      let messages = [];
      let factors = [];

      function addFactor(name, value, msg) {
        if (value > 0) messages.push(msg);
        score += value;
        factors.push({ name, value });
      }

      // Watermark
      addFactor("Watermark", text.includes("‚Äã‚Äå‚Äç‚Å†‚Å°") ? 5 : 0, "üíß Watermark detected ‚Äî strong AI indicator");

      // Contractions
      const contractions = (text.match(/\b(I'm|don't|can't|won't|isn't|aren't|wasn't|weren't|doesn't|didn't|hasn't|haven't|hadn't|shouldn't|wouldn't|couldn't|mustn't|let's|that's|there's|what's|who's|where's|how's)\b/gi) || []).length;
      addFactor("Contractions", contractions < 3 ? 1.5 : 0, "üö´ Few or no contractions (formal tone)");

      // Formal connectors
      const formalIndicators = (text.match(/\b(moreover|furthermore|in addition|additionally|thus|therefore|hence|as a result|in summary|in other words|it is important to note|on the other hand)\b/gi) || []).length;
      addFactor("Connectors", formalIndicators > 2 ? 2 : 0, "üö® Multiple formal connectors ‚Äî possible AI style");

      // Lexical diversity
      const words = text.split(/\s+/);
      const uniqueWords = new Set(words.map(w => w.toLowerCase()));
      addFactor("Lexical Diversity", uniqueWords.size / words.length < 0.4 ? 2 : 0, "üìä Low lexical diversity ‚Äî possible AI summarization");

      // Pronouns
      addFactor("Pronouns", !/\b(I|we|my|our|you)\b/i.test(text) ? 1.5 : 0, "üôÖ‚Äç‚ôÇÔ∏è No personal pronouns ‚Äî neutral AI tone");

      // Repetition
      const bigrams = {};
      for (let i = 0; i < words.length - 1; i++) {
        const pair = words[i].toLowerCase() + " " + words[i + 1].toLowerCase();
        bigrams[pair] = (bigrams[pair] || 0) + 1;
      }
      addFactor("Repetition", Object.values(bigrams).filter(c => c > 2).length > 1 ? 1.5 : 0, "üîÅ Repeated phrase patterns ‚Äî possible AI structuring");

      // Sentence length
      const sentences = text.match(/[^.!?]+[.!?]/g) || [];
      if (sentences.length > 3) {
        const lens = sentences.map(s => s.trim().split(/\s+/).length);
        const avg = lens.reduce((a, b) => a + b, 0) / lens.length;
        const variance = lens.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / lens.length;
        addFactor("Sentence Length", variance < 20 ? 1.5 : 0, "üìè Uniform sentence lengths ‚Äî possible AI drafting");
      } else {
        addFactor("Sentence Length", 0, "");
      }

      // Modal verbs
      const modalCount = (text.match(/\b(should|would|could|might|may|must)\b/gi) || []).length;
      addFactor("Modal Verbs", modalCount > 5 ? 1.5 : 0, "‚öñÔ∏è Heavy modal verbs usage ‚Äî AI hedging style");

      // Hedging language
      const hedgeCount = (text.match(/\b(possibly|potentially|may|might|arguably|perhaps)\b/gi) || []).length;
      addFactor("Hedging", hedgeCount > 3 ? 1.5 : 0, "üí¨ Excessive hedging language ‚Äî possible AI uncertainty");

      // Passive voice (approximate)
      const passiveCount = (text.match(/\b(is|are|was|were|be|been|being)\b\s+\w+ed\b/gi) || []).length;
      addFactor("Passive Voice", passiveCount > 4 ? 1.5 : 0, "üé≠ Frequent passive voice ‚Äî formal AI tone");

      // Combo triggers
      const combos = [
        { pattern: /together, we can.*|collaborative approach/i, value: 2, msg: "üß† Combo: 'together, we can'" },
        { pattern: /influence.*platforms.*responsible/i, value: 2, msg: "üß† Combo: 'influence, platforms, responsible'" },
        { pattern: /strive.*ecosystem.*truth/i, value: 2, msg: "üß† Combo: 'strive, ecosystem, truth'" }
      ];
      let comboScore = 0;
      combos.forEach(rule => {
        if (rule.pattern.test(text)) {
          comboScore += rule.value;
          messages.push(rule.msg);
        }
      });
      score += comboScore;
      factors.push({ name: "Combo Triggers", value: comboScore });

      const matchScore = Math.min(10, score).toFixed(1);
      const highFlag = score > 5 ? "High" : "Moderate";
      document.getElementById("results").innerHTML = `<strong>AI Match Score: ${matchScore}/10</strong><br><strong>Likelihood:</strong> ${highFlag}<br><ul><li>${messages.join("</li><li>")}</li></ul>`;
      drawHorizontalChart(factors);
    }

    function clearDetect() {
      document.getElementById("detectInput").value = "";
      document.getElementById("results").innerHTML = "";
      const ctx = document.getElementById("scoreChart").getContext("2d");
      ctx.clearRect(0, 0, 800, 1000);
    }

    function drawHorizontalChart(factors) {
      const canvas = document.getElementById("scoreChart");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const barHeight = 30;
      const spacing = 25;
      const labelWidth = 180;
      const startX = labelWidth + 20;
      const startY = 30;
      ctx.font = "14px Arial";
      ctx.textAlign = "right";
      const scale = (canvas.width - startX - 50) / 10;
      factors.forEach((factor, i) => {
        const y = startY + i * (barHeight + spacing);
        const barWidth = factor.value * scale;
        ctx.fillStyle = "#000";
        ctx.fillText(factor.name, labelWidth, y + barHeight / 2 + 5);
        ctx.fillStyle = "#4a90e2";
        ctx.fillRect(startX, y, barWidth, barHeight);
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(factor.value.toFixed(1), startX + barWidth / 2, y + barHeight / 2 + 5);
        ctx.textAlign = "right";
      });
    }
  </script>
</body>
</html>
