<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PromptShield ‚Äì Advanced AI Detection & Encoding Tool</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; margin: 20px; padding: 20px; }
    textarea { width: 100%; height: 200px; font-size: 14px; padding: 10px; }
    button { padding: 10px 20px; margin: 10px 5px 0 0; font-size: 16px; cursor: pointer; }
    #output, #results { background: #fff; padding: 15px; margin-top: 20px; border: 1px solid #ccc; border-radius: 5px; white-space: pre-wrap; }
    #spinner { display: none; margin-top: 10px; }
    canvas { margin-top: 20px; background: #fff; border: 1px solid #ccc; border-radius: 5px; }
    #controls { margin-top: 10px; }
    label { font-size: 14px; margin-right: 10px; }
  </style>
</head>
<body>
  <h1>PromptShield ‚Äì Advanced AI Detection & Encoding Tool</h1>

  <div id="controls">
    <button id="tabEncode">Encode Instructions</button>
    <button id="tabDetect">Detect AI Content</button>
    <label>
      Strictness:
      <input id="strictnessSlider" type="range" min="0.5" max="2" step="0.1" value="1">
      <span id="strictnessValue">1.0</span>x
    </label>
  </div>

  <div id="encodeMode">
    <h2>Encode Teacher Instructions</h2>
    <textarea id="encodeInput" placeholder="Paste your instructions..."></textarea><br>
    <button id="btnEncode">Encode</button>
    <button id="btnCopy">Copy to Clipboard</button>
    <div id="output"></div>
  </div>

  <div id="detectMode" style="display:none;">
    <h2>Detect AI Usage</h2>
    <textarea id="detectInput" placeholder="Paste student content..."></textarea><br>
    <button id="btnAnalyze">Analyze</button>
    <button id="btnClear">Clear</button>
    <button id="btnExport">Export Report</button>
    <div id="spinner">üîÑ Analyzing...</div>
    <div id="results"></div>
    <canvas id="scoreChart" width="800" height="600"></canvas>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // Element references
    const tabEncode = document.getElementById('tabEncode');
    const tabDetect = document.getElementById('tabDetect');
    const encodeMode = document.getElementById('encodeMode');
    const detectMode = document.getElementById('detectMode');
    const strictnessSlider = document.getElementById('strictnessSlider');
    const strictnessValue = document.getElementById('strictnessValue');
    const btnEncode = document.getElementById('btnEncode');
    const btnCopy = document.getElementById('btnCopy');
    const btnAnalyze = document.getElementById('btnAnalyze');
    const btnClear = document.getElementById('btnClear');
    const btnExport = document.getElementById('btnExport');
    const spinner = document.getElementById('spinner');
    const output = document.getElementById('output');
    const results = document.getElementById('results');
    const scoreChart = document.getElementById('scoreChart');
    let watermark = '';

    // Tab switching
    tabEncode.addEventListener('click', () => {
      encodeMode.style.display = 'block';
      detectMode.style.display = 'none';
    });
    tabDetect.addEventListener('click', () => {
      encodeMode.style.display = 'none';
      detectMode.style.display = 'block';
    });

    // Strictness slider display
    strictnessValue.textContent = strictnessSlider.value;
    strictnessSlider.addEventListener('input', () => {
      strictnessValue.textContent = strictnessSlider.value;
    });

    // Utility functions
    function normalizeText(text) {
      return text.replace(/[‚Äú‚Äù]/g,'"').replace(/[‚Äò‚Äô]/g,"'")
        .replace(/‚Äî/g,'-').replace(/&[a-z]+;/gi,'').trim();
    }
    function randomWatermark() {
      const chars = ['\u200B','\u200C','\u200D','\u2060'];
      let seq = '';
      const len = 5 + Math.floor(Math.random()*10);
      for (let i = 0; i < len; i++) {
        seq += chars[Math.floor(Math.random()*chars.length)];
      }
      return seq;
    }

    // Encoding logic (preserves formatting)
    btnEncode.addEventListener('click', () => {
      watermark = randomWatermark();
      const text = document.getElementById('encodeInput').value;
      output.innerText = watermark + "\n\n" + text + "\n\n" + watermark;
    });
    btnCopy.addEventListener('click', () => {
      navigator.clipboard.writeText(output.innerText).then(() => alert('Copied!'));
    });

    // Helpers for detection
    function countSyllables(w) {
      w = w.toLowerCase();
      if (w.length <= 3) return 1;
      const m = w.match(/[aeiouy]{1,2}/g);
      return m ? m.length : 1;
    }
    function fleschKincaid(txt) {
      const sents = txt.match(/[^.!?]+[.!?]/g) || [];
      const words = txt.split(/\s+/);
      const sylls = words.reduce((sum, w) => sum + countSyllables(w), 0);
      const ASL = sents.length ? words.length / sents.length : 0;
      const ASW = words.length ? sylls / words.length : 0;
      return 0.39 * ASL + 11.8 * ASW - 15.59;
    }
    function sentimentVariance(pars) {
      const pos = ['good','great','positive','strong','effective','successful','important'];
      const neg = ['weak','bad','problem','issue','difficult','fail','collapse'];
      const scores = pars.map(p => {
        const ws = p.toLowerCase().split(/\W+/);
        let s = 0;
        ws.forEach(w => { if (pos.includes(w)) s++; if (neg.includes(w)) s--; });
        return ws.length ? s/ws.length : 0;
      });
      if (scores.length < 2) return 1;
      const mean = scores.reduce((a,b)=>a+b,0)/scores.length;
      return scores.reduce((a,b)=>a + (b-mean)**2,0)/scores.length;
    }

    // ---- Configurable Weights ----
    const WEIGHTS = {
      Watermark: 5,
      FewContractions: 2,
      RepetitiveStructures: 4.5,
      ExcessiveTransitions: 2,
      UniformParagraphs: 2,
      NoPersonalVoice: 2,
      NumericDensity: 2,
      OpinionInsertion: 1.5,
      RhetoricalQuestions: 2,
      ReadabilityScore: 1.5,
      LowLexicalDiversity: 1.5,
      PassiveVoice: 1.5,
      NgramRepetition: 1.5,
      SentimentUniformity: 1.5,
      HedgeWords: 1.5,
      EmojiUsage: 1.5,
      ComplexPunctuation: 1.5
    };

    // ---- Detection Rules ----
    const RULES = [
      { name: 'Watermark', key: 'Watermark', test: t => t.includes(watermark), msg: 'üíß Watermark detected.' },
      { name: 'Few Contractions', key: 'FewContractions', test: t => (t.match(/\b(I‚Äôm|don‚Äôt|can‚Äôt|won‚Äôt|isn‚Äôt|aren‚Äôt)\b/gi)||[]).length < 4, msg: 'üö´ Few contractions (formal tone)' },
      { name: 'Repetitive Structures', key: 'RepetitiveStructures', test: t => (t.match(/\b(One major reason|Another important cause|A third reason|In conclusion)\b/gi)||[]).length > 2, msg: 'üîÅ Repetitive essay structure' },
      { name: 'Excessive Transitions', key: 'ExcessiveTransitions', test: t => (t.match(/\b(Furthermore|Moreover|Thus|Besides|Finally|Therefore|Additionally|In summary)\b/gi)||[]).length > 3, msg: 'üåÄ Frequent formal transitions' },
      { name: 'Uniform Paragraphs', key: 'UniformParagraphs', test: t => {
          const ps = t.split(/\n+/).filter(p=>p.trim());
          const ls = ps.map(p=>p.split(/\s+/).length);
          const avg = ls.reduce((a,b)=>a+b,0)/ls.length;
          return ls.length>2 && ls.every(l=>Math.abs(l-avg)<10);
        }, msg: 'üìè Uniform paragraph lengths' },
      { name: 'No Personal Voice', key: 'NoPersonalVoice', test: t => (t.match(/\b(I|we|my|our|you|your)\b/gi)||[]).length < 2, msg: 'üôÖ‚Äç‚ôÇÔ∏è Lack of personal voice' },
      { name: 'Numeric Density', key: 'NumericDensity', test: t => {
          const nums = t.match(/\b\d+(?:\.\d+)?%?\b/g)||[];
          return nums.length > t.split(/\s+/).length * 0.03;
        }, msg: 'üî¢ High numeric reference density' },
      { name: 'Opinion Insertion', key: 'OpinionInsertion', test: t => (t.match(/\b(In my opinion|I believe|I think|It is important to note)\b/gi)||[]).length > 0, msg: 'üó£Ô∏è Forced opinion insertion' },
      { name: 'Rhetorical Questions', key: 'RhetoricalQuestions', test: t => (t.match(/\?\s/g)||[]).length < 1, msg: '‚ùì Absence of questions‚ÄîAI tends to avoid them' },  
      { name: 'Readability Score', key: 'ReadabilityScore', test: t => {
          const fk = fleschKincaid(t);
          return fk > 35 && fk < 60;
        }, msg: 'üìê Readability in tighter AI range' },
      { name: 'Low Lexical Diversity', key: 'LowLexicalDiversity', test: t => {
          const ws = t.split(/\s+/), uw = new Set(ws.map(w=>w.toLowerCase()));
          return uw.size/ws.length < 0.4;
        }, msg: 'üìä Low lexical diversity' },
      { name: 'Passive Voice', key: 'PassiveVoice', test: t => (t.match(/\b(is|was|were|been|being)\b\s+\w+ed\b/g)||[]).length > 2, msg: 'üé≠ Frequent passive voice' },
      { name: 'N-gram Repetition', key: 'NgramRepetition', test: t => {
          const ws = t.split(/\s+/), tr = {};
          for (let i = 0; i < ws.length-2; i++){
            const g = ws[i]+' '+ws[i+1]+' '+ws[i+2];
            tr[g] = (tr[g]||0)+1;
            if (tr[g] > 2) return true;
          }
          return false;
        }, msg: 'üîÇ Repeated trigrams' },
      { name: 'Sentiment Uniformity', key: 'SentimentUniformity', test: t => {
          const ps = t.split(/\n+/).filter(p=>p.trim());
          return sentimentVariance(ps) < 0.002;
        }, msg: '‚öñÔ∏è Uniform sentiment across paragraphs' },
      { name: 'Hedge Words', key: 'HedgeWords', test: t => (t.match(/\b(possibly|potentially|arguably|perhaps|somewhat)\b/gi)||[]).length > 3, msg: 'üîç High hedging language' },
      { name: 'Emoji Usage', key: 'EmojiUsage', test: t => (t.match(/[üòÄ-üôè]/g)||[]).length > 1, msg: 'üòä Frequent emoji usage' },
      { name: 'Complex Punctuation', key: 'ComplexPunctuation', test: t => (t.match(/[;:,]/g)||[]).length > 5, msg: '‚úçÔ∏è Complex punctuation usage' }
    ];

    let reportData = {};

    // Analyze button
    btnAnalyze.addEventListener('click', () => {
      spinner.style.display = 'block';
      setTimeout(() => {
        spinner.style.display = 'none';
        const raw = document.getElementById('detectInput').value;
        const text = normalizeText(raw);
        const words = text.split(/\s+/).filter(w=>w);
        if (words.length < 50) {
          results.textContent = 'Not enough data to judge.';
          return;
        }
        const strict = parseFloat(strictnessSlider.value);
        let score = 0, msgs = [], facts = [];
        RULES.forEach(r => {
          if (r.test(text)) {
            const w = WEIGHTS[r.key] * strict;
            score += w; msgs.push(r.msg); facts.push({name:r.name,value:w});
          }
        });
        const finalScore = Math.min(10,score).toFixed(1);
        const likelihood = score > 5 ? 'High' : 'Moderate';
        reportData = {score:finalScore,likelihood,details:facts};
        results.innerHTML =
          `<strong>AI Match Score: ${finalScore}/10</strong><br>` +
          `<strong>Likelihood:</strong> ${likelihood}` +
          `<ul><li>${msgs.join('</li><li>')}</li></ul>`;
        // render chart
        const ctx = scoreChart.getContext('2d');
        ctx.clearRect(0,0,800,600);
        facts.forEach((f,i)=>{
          ctx.fillStyle = '#4a90e2';
          ctx.fillRect(200,i*40+20,f.value*40,25);
          ctx.fillStyle = '#000';
          ctx.fillText(`${f.name}: ${f.value.toFixed(1)}`,10,i*40+35);
        });
      }, 50);
    });

    // Clear and export
    btnClear.addEventListener('click', () => {
      document.getElementById('detectInput').value = '';
      results.innerHTML = '';
      scoreChart.getContext('2d').clearRect(0,0,800,600);
    });
    btnExport.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(reportData,null,2)],{type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'ai_detection_report.json'; a.click(); URL.revokeObjectURL(url);
    });
  });
  </script>
</body>
</html>
